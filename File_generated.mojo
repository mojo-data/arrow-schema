# automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers
from Schema_generated import *

#  ----------------------------------------------------------------------
#  Arrow File metadata
# 
@value
struct Footer:
    var _buf: DTypePointer[DType.uint8]
    var _pos: Int32

    fn version(self) -> MetadataVersion:
        return flatbuffers.field[DType.int16](self._buf, int(self._pos), 4, 0)

    fn schema(self) -> Optional[Schema]:
        var o = flatbuffers.field_table(self._buf, int(self._pos), 6)
        if o:
            return Schema(self._buf, o.take())
        return None

    fn dictionaries(self, i: Int) -> Block:
        var start = flatbuffers.field_vector(self._buf, int(self._pos), 8) + i * 24
        return Block(self._buf, start)

    fn dictionaries_length(self) -> Int:
        return flatbuffers.field_vector_len(self._buf, int(self._pos), 8)

    fn recordBatches(self, i: Int) -> Block:
        var start = flatbuffers.field_vector(self._buf, int(self._pos), 10) + i * 24
        return Block(self._buf, start)

    fn recordBatches_length(self) -> Int:
        return flatbuffers.field_vector_len(self._buf, int(self._pos), 10)

    #  User-defined metadata
    fn custom_metadata(self, i: Int) -> KeyValue:
        var start = flatbuffers.field_vector(self._buf, int(self._pos), 12) + i * 4
        start += int(flatbuffers.indirect(self._buf, start))
        return KeyValue(self._buf, start)

    fn custom_metadata_length(self) -> Int:
        return flatbuffers.field_vector_len(self._buf, int(self._pos), 12)

    @staticmethod
    fn as_root(buf: DTypePointer[DType.uint8]) -> Footer:
        return Footer(buf, flatbuffers.indirect(buf, 0))

    @staticmethod
    fn build(
        inout builder: flatbuffers.Builder,
        *,
        version: MetadataVersion = MetadataVersion(0),
        schema: Optional[flatbuffers.Offset] = None,
        dictionaries: Optional[flatbuffers.Offset] = None,
        recordBatches: Optional[flatbuffers.Offset] = None,
        custom_metadata: List[flatbuffers.Offset] = List[flatbuffers.Offset](),
    ) -> flatbuffers.Offset:
        var _custom_metadata: Optional[flatbuffers.Offset] = None
        if len(custom_metadata) > 0:
            builder.start_vector(4, len(custom_metadata), 4)
            for o in custom_metadata.__reversed__():
                builder.prepend(o[])
            _custom_metadata = builder.end_vector(len(custom_metadata))

        builder.start_object(5)
        if version != MetadataVersion(0):
            builder.prepend(version.value)
            builder.slot(0)
        if schema is not None:
            builder.prepend(schema.value())
            builder.slot(1)
        if dictionaries is not None:
            builder.prepend(dictionaries.value())
            builder.slot(2)
        if recordBatches is not None:
            builder.prepend(recordBatches.value())
            builder.slot(3)
        if _custom_metadata is not None:
            builder.prepend(_custom_metadata.value())
            builder.slot(4)
        return builder.end_object()

@value
struct Block:
    var _buf: DTypePointer[DType.uint8]
    var _pos: Int32

    #  Index to the start of the RecordBlock (note this is past the Message header)
    fn offset(self) -> Int64:
        return flatbuffers.read[DType.int64](self._buf, int(self._pos) + 0)

    #  Length of the metadata
    fn metaDataLength(self) -> Int32:
        return flatbuffers.read[DType.int32](self._buf, int(self._pos) + 8)

    #  Length of the data (this is aligned so there can be a gap between this and
    #  the metadata).
    fn bodyLength(self) -> Int64:
        return flatbuffers.read[DType.int64](self._buf, int(self._pos) + 16)

    @staticmethod
    fn build(
        inout builder: flatbuffers.Builder,
        *,
        offset: Int64,
        metaDataLength: Int32,
        bodyLength: Int64,
    ) -> flatbuffers.Offset:
        builder.prep(8, 24)
        builder.prepend[DType.int64](bodyLength)
        builder.pad(4)
        builder.prepend[DType.int32](metaDataLength)
        builder.prepend[DType.int64](offset)
        return builder.offset()

