# automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers
from .Tensor_generated import *


@value
struct SparseMatrixCompressedAxis(EqualityComparable):
    var value: Int16

    alias Row = SparseMatrixCompressedAxis(0)
    alias Column = SparseMatrixCompressedAxis(1)

    fn __eq__(self, other: SparseMatrixCompressedAxis) -> Bool:
        return self.value == other.value

    fn __ne__(self, other: SparseMatrixCompressedAxis) -> Bool:
        return self.value != other.value


@value
struct SparseTensorIndex(EqualityComparable):
    var value: UInt8

    alias NONE = SparseTensorIndex(0)
    alias SparseTensorIndexCOO = SparseTensorIndex(1)
    alias SparseMatrixIndexCSX = SparseTensorIndex(2)
    alias SparseTensorIndexCSF = SparseTensorIndex(3)

    fn __eq__(self, other: SparseTensorIndex) -> Bool:
        return self.value == other.value

    fn __ne__(self, other: SparseTensorIndex) -> Bool:
        return self.value != other.value


#  ----------------------------------------------------------------------
#  EXPERIMENTAL: Data structures for sparse tensors
#  Coordinate (COO) format of sparse tensor index.
#
#  COO's index list are represented as a NxM matrix,
#  where N is the number of non-zero values,
#  and M is the number of dimensions of a sparse tensor.
#
#  indicesBuffer stores the location and size of the data of this indices
#  matrix.  The value type and the stride of the indices matrix is
#  specified in indicesType and indicesStrides fields.
#
#  For example, let X be a 2x3x4x5 tensor, and it has the following
#  6 non-zero values:
#  ```text
#    X[0, 1, 2, 0] := 1
#    X[1, 1, 2, 3] := 2
#    X[0, 2, 1, 0] := 3
#    X[0, 1, 3, 0] := 4
#    X[0, 1, 2, 1] := 5
#    X[1, 2, 0, 4] := 6
#  ```
#  In COO format, the index matrix of X is the following 4x6 matrix:
#  ```text
#    [[0, 0, 0, 0, 1, 1],
#     [1, 1, 1, 2, 1, 2],
#     [2, 2, 3, 1, 2, 0],
#     [0, 1, 0, 0, 3, 4]]
#  ```
#  When isCanonical is true, the indices is sorted in lexicographical order
#  (row-major order), and it does not have duplicated entries.  Otherwise,
#  the indices may not be sorted, or may have duplicated entries.
@value
struct SparseTensorIndexCOO:
    var _buf: UnsafePointer[UInt8]
    var _pos: Int

    #  The type of values in indicesBuffer
    fn indicesType(self) -> Int_:
        var o = flatbuffers.field_table(self._buf, int(self._pos), 4)
        return Int_(self._buf, o.take())

    #  Non-negative byte offsets to advance one value cell along each dimension
    #  If omitted, default to row-major order (C-like).
    fn indicesStrides(self, i: Int) -> Int64:
        return flatbuffers.read[DType.int64](
            self._buf,
            flatbuffers.field_vector(self._buf, int(self._pos), 6) + i * 8,
        )

    fn has_indicesStrides(self) -> Bool:
        return flatbuffers.has_field(self._buf, int(self._pos), 6)

    fn indicesStrides_length(self) -> Int:
        return flatbuffers.field_vector_len(self._buf, int(self._pos), 6)

    #  The location and size of the indices matrix's data
    fn indicesBuffer(self) -> Buffer:
        var o = flatbuffers.field_struct(self._buf, int(self._pos), 8)
        return Buffer(self._buf, o.take())

    #  This flag is true if and only if the indices matrix is sorted in
    #  row-major order, and does not have duplicated entries.
    #  This sort order is the same as of Tensorflow's SparseTensor,
    #  but it is inverse order of SciPy's canonical coo_matrix
    #  (SciPy employs column-major order for its coo_matrix).
    fn isCanonical(self) -> Scalar[DType.bool]:
        return flatbuffers.field[DType.bool](self._buf, int(self._pos), 10, 0)

    @staticmethod
    fn as_root(buf: UnsafePointer[UInt8]) -> SparseTensorIndexCOO:
        return SparseTensorIndexCOO(buf, flatbuffers.read_offset_as_int(buf, 0))

    @staticmethod
    fn build(
        inout builder: flatbuffers.Builder,
        *,
        indicesType: flatbuffers.Offset,
        indicesBuffer: BufferVO,
        indicesStrides: List[Int64] = List[Int64](),
        isCanonical: Scalar[DType.bool] = 0,
    ) -> flatbuffers.Offset:
        var _indicesStrides: Optional[flatbuffers.Offset] = None
        if len(indicesStrides) > 0:
            builder.start_vector(8, len(indicesStrides), 8)
            for o in indicesStrides.__reversed__():
                builder.prepend(o[])
            _indicesStrides = builder.end_vector(len(indicesStrides))

        builder.start_object(4)
        builder.prepend(indicesType)
        builder.slot(0)
        if _indicesStrides is not None:
            builder.prepend(_indicesStrides.value())
            builder.slot(1)
        Buffer.build(
            builder,
            offset=indicesBuffer.offset,
            length=indicesBuffer.length,
        )
        builder.slot(2)
        if isCanonical != 0:
            builder.prepend(isCanonical)
            builder.slot(3)
        return builder.end_object()


#  Compressed Sparse format, that is matrix-specific.
@value
struct SparseMatrixIndexCSX:
    var _buf: UnsafePointer[UInt8]
    var _pos: Int

    #  Which axis, row or column, is compressed
    fn compressedAxis(self) -> SparseMatrixCompressedAxis:
        return flatbuffers.field[DType.int16](self._buf, int(self._pos), 4, 0)

    #  The type of values in indptrBuffer
    fn indptrType(self) -> Int_:
        var o = flatbuffers.field_table(self._buf, int(self._pos), 6)
        return Int_(self._buf, o.take())

    #  indptrBuffer stores the location and size of indptr array that
    #  represents the range of the rows.
    #  The i-th row spans from `indptr[i]` to `indptr[i+1]` in the data.
    #  The length of this array is 1 + (the number of rows), and the type
    #  of index value is long.
    #
    #  For example, let X be the following 6x4 matrix:
    #  ```text
    #    X := [[0, 1, 2, 0],
    #          [0, 0, 3, 0],
    #          [0, 4, 0, 5],
    #          [0, 0, 0, 0],
    #          [6, 0, 7, 8],
    #          [0, 9, 0, 0]].
    #  ```
    #  The array of non-zero values in X is:
    #  ```text
    #    values(X) = [1, 2, 3, 4, 5, 6, 7, 8, 9].
    #  ```
    #  And the indptr of X is:
    #  ```text
    #    indptr(X) = [0, 2, 3, 5, 5, 8, 10].
    #  ```
    fn indptrBuffer(self) -> Buffer:
        var o = flatbuffers.field_struct(self._buf, int(self._pos), 8)
        return Buffer(self._buf, o.take())

    #  The type of values in indicesBuffer
    fn indicesType(self) -> Int_:
        var o = flatbuffers.field_table(self._buf, int(self._pos), 10)
        return Int_(self._buf, o.take())

    #  indicesBuffer stores the location and size of the array that
    #  contains the column indices of the corresponding non-zero values.
    #  The type of index value is long.
    #
    #  For example, the indices of the above X is:
    #  ```text
    #    indices(X) = [1, 2, 2, 1, 3, 0, 2, 3, 1].
    #  ```
    #  Note that the indices are sorted in lexicographical order for each row.
    fn indicesBuffer(self) -> Buffer:
        var o = flatbuffers.field_struct(self._buf, int(self._pos), 12)
        return Buffer(self._buf, o.take())

    @staticmethod
    fn as_root(buf: UnsafePointer[UInt8]) -> SparseMatrixIndexCSX:
        return SparseMatrixIndexCSX(buf, flatbuffers.read_offset_as_int(buf, 0))

    @staticmethod
    fn build(
        inout builder: flatbuffers.Builder,
        *,
        indptrType: flatbuffers.Offset,
        indptrBuffer: BufferVO,
        indicesType: flatbuffers.Offset,
        indicesBuffer: BufferVO,
        compressedAxis: SparseMatrixCompressedAxis = SparseMatrixCompressedAxis(
            0
        ),
    ) -> flatbuffers.Offset:
        builder.start_object(5)
        if compressedAxis != SparseMatrixCompressedAxis(0):
            builder.prepend(compressedAxis.value)
            builder.slot(0)
        builder.prepend(indptrType)
        builder.slot(1)
        Buffer.build(
            builder,
            offset=indptrBuffer.offset,
            length=indptrBuffer.length,
        )
        builder.slot(2)
        builder.prepend(indicesType)
        builder.slot(3)
        Buffer.build(
            builder,
            offset=indicesBuffer.offset,
            length=indicesBuffer.length,
        )
        builder.slot(4)
        return builder.end_object()


#  Compressed Sparse Fiber (CSF) sparse tensor index.
@value
struct SparseTensorIndexCSF:
    var _buf: UnsafePointer[UInt8]
    var _pos: Int

    #  CSF is a generalization of compressed sparse row (CSR) index.
    #  See [smith2017knl](http://shaden.io/pub-files/smith2017knl.pdf)
    #
    #  CSF index recursively compresses each dimension of a tensor into a set
    #  of prefix trees. Each path from a root to leaf forms one tensor
    #  non-zero index. CSF is implemented with two arrays of buffers and one
    #  arrays of integers.
    #
    #  For example, let X be a 2x3x4x5 tensor and let it have the following
    #  8 non-zero values:
    #  ```text
    #    X[0, 0, 0, 1] := 1
    #    X[0, 0, 0, 2] := 2
    #    X[0, 1, 0, 0] := 3
    #    X[0, 1, 0, 2] := 4
    #    X[0, 1, 1, 0] := 5
    #    X[1, 1, 1, 0] := 6
    #    X[1, 1, 1, 1] := 7
    #    X[1, 1, 1, 2] := 8
    #  ```
    #  As a prefix tree this would be represented as:
    #  ```text
    #          0          1
    #         / \         |
    #        0   1        1
    #       /   / \       |
    #      0   0   1      1
    #     /|  /|   |    /| |
    #    1 2 0 2   0   0 1 2
    #  ```
    #  The type of values in indptrBuffers
    fn indptrType(self) -> Int_:
        var o = flatbuffers.field_table(self._buf, int(self._pos), 4)
        return Int_(self._buf, o.take())

    #  indptrBuffers stores the sparsity structure.
    #  Each two consecutive dimensions in a tensor correspond to a buffer in
    #  indptrBuffers. A pair of consecutive values at `indptrBuffers[dim][i]`
    #  and `indptrBuffers[dim][i + 1]` signify a range of nodes in
    #  `indicesBuffers[dim + 1]` who are children of `indicesBuffers[dim][i]` node.
    #
    #  For example, the indptrBuffers for the above X is:
    #  ```text
    #    indptrBuffer(X) = [
    #                        [0, 2, 3],
    #                        [0, 1, 3, 4],
    #                        [0, 2, 4, 5, 8]
    #                      ].
    #  ```
    fn indptrBuffers(self, i: Int) -> Buffer:
        var start = flatbuffers.field_vector(
            self._buf, int(self._pos), 6
        ) + i * 16
        return Buffer(self._buf, start)

    fn indptrBuffers_length(self) -> Int:
        return flatbuffers.field_vector_len(self._buf, int(self._pos), 6)

    #  The type of values in indicesBuffers
    fn indicesType(self) -> Int_:
        var o = flatbuffers.field_table(self._buf, int(self._pos), 8)
        return Int_(self._buf, o.take())

    #  indicesBuffers stores values of nodes.
    #  Each tensor dimension corresponds to a buffer in indicesBuffers.
    #  For example, the indicesBuffers for the above X is:
    #  ```text
    #    indicesBuffer(X) = [
    #                         [0, 1],
    #                         [0, 1, 1],
    #                         [0, 0, 1, 1],
    #                         [1, 2, 0, 2, 0, 0, 1, 2]
    #                       ].
    #  ```
    fn indicesBuffers(self, i: Int) -> Buffer:
        var start = flatbuffers.field_vector(
            self._buf, int(self._pos), 10
        ) + i * 16
        return Buffer(self._buf, start)

    fn indicesBuffers_length(self) -> Int:
        return flatbuffers.field_vector_len(self._buf, int(self._pos), 10)

    #  axisOrder stores the sequence in which dimensions were traversed to
    #  produce the prefix tree.
    #  For example, the axisOrder for the above X is:
    #  ```text
    #    axisOrder(X) = [0, 1, 2, 3].
    #  ```
    fn axisOrder(self, i: Int) -> Int32:
        return flatbuffers.read[DType.int32](
            self._buf,
            flatbuffers.field_vector(self._buf, int(self._pos), 12) + i * 4,
        )

    fn axisOrder_length(self) -> Int:
        return flatbuffers.field_vector_len(self._buf, int(self._pos), 12)

    @staticmethod
    fn as_root(buf: UnsafePointer[UInt8]) -> SparseTensorIndexCSF:
        return SparseTensorIndexCSF(buf, flatbuffers.read_offset_as_int(buf, 0))

    @staticmethod
    fn build(
        inout builder: flatbuffers.Builder,
        *,
        indptrType: flatbuffers.Offset,
        indptrBuffers: List[BufferVO],
        indicesType: flatbuffers.Offset,
        indicesBuffers: List[BufferVO],
        axisOrder: List[Int32],
    ) -> flatbuffers.Offset:
        var _indptrBuffers: Optional[flatbuffers.Offset] = None
        if len(indptrBuffers) > 0:
            builder.start_vector(16, len(indptrBuffers), 8)
            for o in indptrBuffers.__reversed__():
                Buffer.build(
                    builder,
                    offset=o[].offset,
                    length=o[].length,
                )
            _indptrBuffers = builder.end_vector(len(indptrBuffers))

        var _indicesBuffers: Optional[flatbuffers.Offset] = None
        if len(indicesBuffers) > 0:
            builder.start_vector(16, len(indicesBuffers), 8)
            for o in indicesBuffers.__reversed__():
                Buffer.build(
                    builder,
                    offset=o[].offset,
                    length=o[].length,
                )
            _indicesBuffers = builder.end_vector(len(indicesBuffers))

        var _axisOrder: Optional[flatbuffers.Offset] = None
        if len(axisOrder) > 0:
            builder.start_vector(4, len(axisOrder), 4)
            for o in axisOrder.__reversed__():
                builder.prepend(o[])
            _axisOrder = builder.end_vector(len(axisOrder))

        builder.start_object(5)
        builder.prepend(indptrType)
        builder.slot(0)
        if _indptrBuffers is not None:
            builder.prepend(_indptrBuffers.value())
            builder.slot(1)
        builder.prepend(indicesType)
        builder.slot(2)
        if _indicesBuffers is not None:
            builder.prepend(_indicesBuffers.value())
            builder.slot(3)
        if _axisOrder is not None:
            builder.prepend(_axisOrder.value())
            builder.slot(4)
        return builder.end_object()


@value
struct SparseTensor:
    var _buf: UnsafePointer[UInt8]
    var _pos: Int

    fn type_type(self) -> Type:
        return flatbuffers.field[DType.uint8](self._buf, int(self._pos), 4, 0)

    #  The type of data contained in a value cell.
    #  Currently only fixed-width value types are supported,
    #  no strings or nested types.
    fn type_as_Null(self) -> Null:
        return Null(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_Int(self) -> Int_:
        return Int_(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_FloatingPoint(self) -> FloatingPoint:
        return FloatingPoint(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_Binary(self) -> Binary:
        return Binary(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_Utf8(self) -> Utf8:
        return Utf8(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_Bool(self) -> Bool_:
        return Bool_(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_Decimal(self) -> Decimal:
        return Decimal(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_Date(self) -> Date:
        return Date(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_Time(self) -> Time:
        return Time(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_Timestamp(self) -> Timestamp:
        return Timestamp(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_Interval(self) -> Interval:
        return Interval(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_List(self) -> List_:
        return List_(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_Struct_(self) -> Struct_:
        return Struct_(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_Union(self) -> Union:
        return Union(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_FixedSizeBinary(self) -> FixedSizeBinary:
        return FixedSizeBinary(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_FixedSizeList(self) -> FixedSizeList:
        return FixedSizeList(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_Map(self) -> Map:
        return Map(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_Duration(self) -> Duration:
        return Duration(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_LargeBinary(self) -> LargeBinary:
        return LargeBinary(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_LargeUtf8(self) -> LargeUtf8:
        return LargeUtf8(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_LargeList(self) -> LargeList:
        return LargeList(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_RunEndEncoded(self) -> RunEndEncoded:
        return RunEndEncoded(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_BinaryView(self) -> BinaryView:
        return BinaryView(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_Utf8View(self) -> Utf8View:
        return Utf8View(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_ListView(self) -> ListView:
        return ListView(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    fn type_as_LargeListView(self) -> LargeListView:
        return LargeListView(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 6).or_else(0),
        )

    #  The dimensions of the tensor, optionally named.
    fn shape(self, i: Int) -> TensorDim:
        var start = flatbuffers.field_vector(
            self._buf, int(self._pos), 8
        ) + i * 4
        start += flatbuffers.read_offset_as_int(self._buf, start)
        return TensorDim(self._buf, start)

    fn shape_length(self) -> Int:
        return flatbuffers.field_vector_len(self._buf, int(self._pos), 8)

    #  The number of non-zero values in a sparse tensor.
    fn non_zero_length(self) -> Int64:
        return flatbuffers.field[DType.int64](self._buf, int(self._pos), 10, 0)

    fn sparseIndex_type(self) -> SparseTensorIndex:
        return flatbuffers.field[DType.uint8](self._buf, int(self._pos), 12, 0)

    #  Sparse tensor index
    fn sparseIndex_as_SparseTensorIndexCOO(self) -> SparseTensorIndexCOO:
        return SparseTensorIndexCOO(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 14).or_else(0),
        )

    fn sparseIndex_as_SparseMatrixIndexCSX(self) -> SparseMatrixIndexCSX:
        return SparseMatrixIndexCSX(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 14).or_else(0),
        )

    fn sparseIndex_as_SparseTensorIndexCSF(self) -> SparseTensorIndexCSF:
        return SparseTensorIndexCSF(
            self._buf,
            flatbuffers.field_table(self._buf, int(self._pos), 14).or_else(0),
        )

    #  The location and size of the tensor's data
    fn data(self) -> Buffer:
        var o = flatbuffers.field_struct(self._buf, int(self._pos), 16)
        return Buffer(self._buf, o.take())

    @staticmethod
    fn as_root(buf: UnsafePointer[UInt8]) -> SparseTensor:
        return SparseTensor(buf, flatbuffers.read_offset_as_int(buf, 0))

    @staticmethod
    fn build(
        inout builder: flatbuffers.Builder,
        *,
        type: flatbuffers.Offset,
        shape: List[flatbuffers.Offset],
        sparseIndex: flatbuffers.Offset,
        data: BufferVO,
        type_type: Type = Type(0),
        non_zero_length: Int64 = 0,
        sparseIndex_type: SparseTensorIndex = SparseTensorIndex(0),
    ) -> flatbuffers.Offset:
        var _shape: Optional[flatbuffers.Offset] = None
        if len(shape) > 0:
            builder.start_vector(4, len(shape), 4)
            for o in shape.__reversed__():
                builder.prepend(o[])
            _shape = builder.end_vector(len(shape))

        builder.start_object(7)
        if type_type != Type(0):
            builder.prepend(type_type.value)
            builder.slot(0)
        builder.prepend(type)
        builder.slot(1)
        if _shape is not None:
            builder.prepend(_shape.value())
            builder.slot(2)
        if non_zero_length != 0:
            builder.prepend(non_zero_length)
            builder.slot(3)
        if sparseIndex_type != SparseTensorIndex(0):
            builder.prepend(sparseIndex_type.value)
            builder.slot(4)
        builder.prepend(sparseIndex)
        builder.slot(5)
        Buffer.build(
            builder,
            offset=data.offset,
            length=data.length,
        )
        builder.slot(6)
        return builder.end_object()
